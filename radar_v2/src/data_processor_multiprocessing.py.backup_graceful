#!/usr/bin/env python3
"""
Data Processor with Multiprocessing
ë©€í‹°í”„ë¡œì„¸ì‹±ì„ ì‚¬ìš©í•œ ê³ ì† ë°ì´í„° ì²˜ë¦¬ ëª¨ë“ˆ
"""

import struct
import time
import logging
import requests
import multiprocessing as mp
from multiprocessing import Process, Queue, Manager
from typing import Dict, Any, Optional, List
import numpy as np
import os
import sys

def _worker_process_protobuf(input_queue: mp.Queue, output_queue: mp.Queue, config: Dict[str, Any], worker_id: int):
    """
    ë©€í‹°í”„ë¡œì„¸ì‹± ì›Œì»¤ í”„ë¡œì„¸ìŠ¤

    Args:
        input_queue: ìž…ë ¥ ë©”ì‹œì§€ í
        output_queue: ì¶œë ¥ ê²°ê³¼ í
        config: ì„¤ì • ë”•ì…”ë„ˆë¦¬
        worker_id: ì›Œì»¤ ID
    """
    # ê° ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ì—ì„œ ë…ë¦½ì ìœ¼ë¡œ DataProcessorë¥¼ import
    # (ë©€í‹°í”„ë¡œì„¸ì‹± ì‹œ ê° í”„ë¡œì„¸ìŠ¤ëŠ” ë…ë¦½ëœ Python ì¸í„°í”„ë¦¬í„°)
    current_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(current_dir)

    # sys.path ì„¤ì •
    if current_dir not in sys.path:
        sys.path.insert(0, current_dir)
    if parent_dir not in sys.path:
        sys.path.insert(0, parent_dir)

    # DataProcessor import
    try:
        from src.data_processor import DataProcessor
    except ImportError:
        # fallback: ì§ì ‘ íŒŒì¼ì—ì„œ import
        import importlib.util
        spec = importlib.util.spec_from_file_location(
            "data_processor",
            os.path.join(current_dir, "data_processor.py")
        )
        data_processor_module = importlib.util.module_from_spec(spec)
        sys.modules['data_processor'] = data_processor_module
        spec.loader.exec_module(data_processor_module)
        DataProcessor = data_processor_module.DataProcessor

    # ê° ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ì—ì„œ ë…ë¦½ì ì¸ DataProcessor ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
    processor = DataProcessor(config)

    # ë¡œê¹… ì„¤ì • (ì›Œì»¤ë³„ë¡œ êµ¬ë¶„)
    logger = logging.getLogger(f"worker_{worker_id}")

    logger.info(f"ðŸ”§ ì›Œì»¤ {worker_id} ì‹œìž‘")

    while True:
        try:
            # ìž…ë ¥ íì—ì„œ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸° (íƒ€ìž„ì•„ì›ƒ 1ì´ˆ)
            message_data = input_queue.get(timeout=1.0)

            # ì¢…ë£Œ ì‹ í˜¸ í™•ì¸
            if message_data is None:
                logger.info(f"ðŸ›‘ ì›Œì»¤ {worker_id} ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ ")
                break

            # ë©”ì‹œì§€ ì²˜ë¦¬
            start_time = time.time()
            result = processor.process_message(message_data)
            process_time = time.time() - start_time

            # ê²°ê³¼ë¥¼ ì¶œë ¥ íì— ë„£ê¸°
            if result:
                output_queue.put({
                    'worker_id': worker_id,
                    'result': result,
                    'process_time': process_time
                })

        except mp.queues.Empty:
            # íƒ€ìž„ì•„ì›ƒ ë°œìƒ - ì •ìƒì ì¸ ìƒí™©, ê³„ì† ëŒ€ê¸°
            continue
        except Exception as e:
            # ì‹¤ì œ ì—ëŸ¬ ë°œìƒ - ìƒì„¸ ì •ë³´ ì¶œë ¥
            import traceback
            logger.error(f"ì›Œì»¤ {worker_id} ì˜¤ë¥˜: {type(e).__name__}: {str(e)}")
            logger.error(f"ìƒì„¸:\n{traceback.format_exc()}")
            continue

    logger.info(f"âœ… ì›Œì»¤ {worker_id} ì¢…ë£Œ")


class DataProcessorMultiprocessing:
    """ë©€í‹°í”„ë¡œì„¸ì‹±ì„ ì‚¬ìš©í•˜ëŠ” ê³ ì† ë°ì´í„° í”„ë¡œì„¸ì„œ"""

    def __init__(self, config: Dict[str, Any], num_workers: int = 4):
        """
        DataProcessorMultiprocessing ì´ˆê¸°í™”

        Args:
            config: ì„¤ì • ë”•ì…”ë„ˆë¦¬
            num_workers: ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ ìˆ˜ (ê¸°ë³¸ê°’: 4)
        """
        self.config = config
        self.num_workers = num_workers
        self.logger = logging.getLogger(__name__)

        # ë©€í‹°í”„ë¡œì„¸ì‹± í ìƒì„±
        # í í¬ê¸°ë¥¼ ì¦ê°€ì‹œì¼œ ë©”ì‹œì§€ ë“œë¡­ ë°©ì§€
        self.input_queue = mp.Queue(maxsize=500)  # ìž…ë ¥ í í¬ê¸° ì œí•œ
        self.output_queue = mp.Queue(maxsize=500)  # ì¶œë ¥ í í¬ê¸° ì œí•œ

        # ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ ë¦¬ìŠ¤íŠ¸
        self.workers = []

        # í†µê³„
        self.stats = {
            'total_processed': 0,
            'total_dropped': 0,
            'process_times': [],
        }

        self.is_running = False

    def start(self):
        """ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ ì‹œìž‘"""
        if self.is_running:
            self.logger.warning("ì´ë¯¸ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤.")
            return

        self.is_running = True

        # ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ ì‹œìž‘
        for i in range(self.num_workers):
            worker = Process(
                target=_worker_process_protobuf,
                args=(self.input_queue, self.output_queue, self.config, i),
                daemon=True
            )
            worker.start()
            self.workers.append(worker)

        self.logger.info(f"ðŸš€ ë©€í‹°í”„ë¡œì„¸ì‹± ì‹œìž‘: {self.num_workers}ê°œ ì›Œì»¤")

    def stop(self):
        """ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ ì¤‘ì§€"""
        if not self.is_running:
            return

        self.is_running = False

        # ëª¨ë“  ì›Œì»¤ì— ì¢…ë£Œ ì‹ í˜¸ ì „ì†¡
        for _ in range(self.num_workers):
            self.input_queue.put(None)

        # ëª¨ë“  ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ëŒ€ê¸°
        for worker in self.workers:
            worker.join(timeout=5)
            if worker.is_alive():
                worker.terminate()

        self.workers.clear()
        self.logger.info("ðŸ›‘ ë©€í‹°í”„ë¡œì„¸ì‹± ì¤‘ì§€")

    def process_message(self, message_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        ë©”ì‹œì§€ë¥¼ ì›Œì»¤ í”„ë¡œì„¸ìŠ¤ì— ì „ë‹¬ (ë¹„ë¸”ë¡œí‚¹)

        Args:
            message_data: SENSR ë©”ì‹œì§€ ë°ì´í„°

        Returns:
            None (ê²°ê³¼ëŠ” get_result()ë¡œ ê°€ì ¸ì˜´)
        """
        if not self.is_running:
            self.logger.warning("ë©€í‹°í”„ë¡œì„¸ì‹±ì´ ì‹œìž‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return None

        try:
            # ìž…ë ¥ íì— ë©”ì‹œì§€ ì¶”ê°€ (ë¹„ë¸”ë¡œí‚¹)
            self.input_queue.put_nowait(message_data)
            return None  # ë¹„ë™ê¸° ì²˜ë¦¬

        except Exception as e:
            self.stats['total_dropped'] += 1
            self.logger.warning(f"ìž…ë ¥ í ê°€ë“ì°¸! ë©”ì‹œì§€ ë“œë¡­ (ì´ {self.stats['total_dropped']}ê°œ)")
            return None

    def get_result(self, timeout: float = 0.1) -> Optional[Dict[str, Any]]:
        """
        ì²˜ë¦¬ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°

        Args:
            timeout: íƒ€ìž„ì•„ì›ƒ (ì´ˆ)

        Returns:
            ì²˜ë¦¬ëœ ê²°ê³¼ ë˜ëŠ” None
        """
        try:
            result_data = self.output_queue.get(timeout=timeout)

            # í†µê³„ ì—…ë°ì´íŠ¸
            self.stats['total_processed'] += 1
            self.stats['process_times'].append(result_data['process_time'])

            return result_data['result']

        except:
            return None

    def get_stats(self) -> Dict[str, Any]:
        """í†µê³„ ì •ë³´ ë°˜í™˜"""
        avg_process_time = 0
        if self.stats['process_times']:
            avg_process_time = sum(self.stats['process_times']) / len(self.stats['process_times'])

        return {
            'num_workers': self.num_workers,
            'total_processed': self.stats['total_processed'],
            'total_dropped': self.stats['total_dropped'],
            'avg_process_time': avg_process_time,
            'input_queue_size': self.input_queue.qsize(),
            'output_queue_size': self.output_queue.qsize(),
        }
